const express = require('express');
const oracledb = require('oracledb');
const bodyParser = require('body-parser');

const app = express();
const path = require('path');
app.use(express.static(path.join(__dirname, 'public')));
app.use(bodyParser.json());

const dbConfig = {
  user: 'ZANESCUC_67',
  password: 'stud',
  connectString: '//193.226.34.57:1521/orclpdb.docker.internal'
};

async function initialize() {
  try {
    await oracledb.createPool(dbConfig);
    console.log('Connected to Oracle DB');

    const connection = await oracledb.getConnection();
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE tasks (
          id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          title VARCHAR2(100) NOT NULL,
          description VARCHAR2(4000),
          deadline DATE,
          completed NUMBER(1) DEFAULT 0 NOT NULL
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN -- 955 = tabel deja exista
            RAISE;
          END IF;
      END;
    `);
    await connection.close();
    console.log('Table "tasks" is ready');
  } catch (err) {
    console.error('Error initializing DB:', err);
  }
}

app.get('/tasks', async (req, res) => {
  let connection;
  try {
    connection = await oracledb.getConnection();
    const result = await connection.execute(
        'SELECT * FROM tasks ORDER BY id',
        [],
        { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    res.json(result.rows);
  } catch (err) {
    res.status(500).json({ error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (err) {}
    }
  }
});

app.post('/tasks', async (req, res) => {
  const { title, description, deadline } = req.body;
  if (!title) return res.status(400).json({ error: 'Title is required' });

  let connection;
  try {
    connection = await oracledb.getConnection();
    await connection.execute(
        `INSERT INTO tasks (title, description, deadline, completed) VALUES (:title, :description, TO_DATE(:deadline, 'YYYY-MM-DD'), 0)`,
        [title, description || null, deadline || null],
        { autoCommit: true }
    );
    res.json({ message: 'Task added' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (err) {}
    }
  }
});

app.delete('/tasks/:id', async (req, res) => {
  const id = req.params.id;
  let connection;
  try {
    connection = await oracledb.getConnection();
    const result = await connection.execute(
      `DELETE FROM tasks WHERE id = :id`,
      [id],
      { autoCommit: true }
    );
    if (result.rowsAffected === 0) {
      res.status(404).json({ error: 'Task not found' });
    } else {
      res.json({ message: 'Task deleted' });
    }
  } catch (err) {
    res.status(500).json({ error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (err) {}
    }
  }
});

app.put('/tasks/:id', async (req, res) => {
  const id = req.params.id;
  const { completed } = req.body;

  if (completed !== 0 && completed !== 1) {
  return res.status(400).json({ error: 'Completed must be 0 sau 1' });
}

  let connection;
  try {
    connection = await oracledb.getConnection();
    const result = await connection.execute(
      `UPDATE tasks SET completed = :completed WHERE id = :id`,
      [completed ? 1 : 0, id],
      { autoCommit: true }
    );
    if (result.rowsAffected === 0) {
      res.status(404).json({ error: 'Task not found' });
    } else {
      res.json({ message: 'Task updated' });
    }
  } catch (err) {
    res.status(500).json({ error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (err) {}
    }
  }
});

const PORT = process.env.PORT || 3000;
initialize().then(() => {
  app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
});

